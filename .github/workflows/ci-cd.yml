name: Branch-Based Deployment with Semantic Versioning

# Trigger conditions for the workflow
on:
  push:
    branches:
      - dev # Development branch
      - main # Production branch
      - sandbox # Testing/staging branch
    tags:
      - "v[0-9]+.[0-9]+.[0-9]+" # Semantic version tags (v1.0.0 format)
  pull_request:
    branches:
      - dev # Run CI checks on PRs to dev

# Global environment variables
env:
  REGISTRY: ghcr.io # GitHub Container Registry
  IMAGE_NAME: ${{ github.repository_owner }}/cicd-nextapp

jobs:
  # ==============================================
  # Version Check Job - Determines version number
  # ==============================================
  version-check:
    runs-on: ubuntu-latest
    outputs:
      should_version: ${{ steps.check.outputs.should_version }} # Whether to generate version
      version: ${{ steps.version.outputs.version }} # Generated version number

    steps:
      # Checkout code with full history for version analysis
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Required to access full commit history

      # Determine if we should generate a semantic version
      - name: Check version generation condition
        id: check
        run: |
          # Only generate versions for main branch or version tags
          if [[ "${{ github.ref }}" == "refs/heads/main" || "${{ github.ref }}" == refs/tags/* ]]; then
            echo "should_version=true" >> $GITHUB_OUTPUT
          else
            echo "should_version=false" >> $GITHUB_OUTPUT
          fi

      # Generate semantic version based on commit messages
      - name: Generate Semantic Version
        id: version
        if: steps.check.outputs.should_version == 'true'
        uses: paulhatch/semantic-version@v3
        with:
          major_pattern: "BREAKING CHANGE" # Major version bump for breaking changes
          minor_pattern: "feat" # Minor version bump for new features
          patch_pattern: "fix" # Patch version bump for bug fixes
          format: "{major}.{minor}.{patch}" # Version format (1.0.0)

  # ==============================================
  # Build Job - Builds and tags Docker image
  # ==============================================
  build:
    needs: version-check # Depends on version-check job
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      # Set up Node.js environment
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "20" # LTS version

      # Install dependencies and build the application
      - name: Install dependencies and build
        run: |
          npm install
          npm run build

      # Determine the appropriate Docker image tag
      - name: Determine Docker Tag
        id: tag
        run: |
          if [[ "${{ needs.version-check.outputs.should_version }}" == "true" ]]; then
            # Use semantic version for main branch or tags
            echo "tag=${{ needs.version-check.outputs.version }}" >> $GITHUB_OUTPUT
          else
            # Use branch name and commit SHA for other branches
            echo "tag=${{ github.ref_name }}-$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          fi

      # Authenticate with GitHub Container Registry
      - name: Log in to GitHub Container Registry
        run: echo "${{ secrets.GH_AT }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

      # Build and push Docker image with appropriate tags
      - name: Build and Push Docker Image
        run: |
          # Main image tag
          FULL_TAG=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tag.outputs.tag }}
          docker build -t $FULL_TAG .
          docker push $FULL_TAG

          # Additional 'latest' tag for main branch
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            LATEST_TAG=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
            docker tag $FULL_TAG $LATEST_TAG
            docker push $LATEST_TAG
          fi

      # Create Git tag for releases (main branch only)
      - name: Create Git Tag
        if: needs.version-check.outputs.should_version == 'true' && github.ref == 'refs/heads/main'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag v${{ needs.version-check.outputs.version }}
          git push origin v${{ needs.version-check.outputs.version }}

      # Cleanup Docker credentials (security best practice)
      - name: Cleanup Docker Login
        if: always()
        run: docker logout ${{ env.REGISTRY }}

  # ==============================================
  # Deploy Job - Deploys to appropriate environment
  # ==============================================
  deploy:
    runs-on: ubuntu-latest
    needs: build # Depends on build job
    # Only run for branch pushes (not pull requests)
    if: (github.ref == 'refs/heads/dev' || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/sandbox') && github.event_name != 'pull_request'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Set environment-specific variables
      - name: Determine Environment
        id: set-env
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/dev" ]]; then
            echo "ENV=development" >> $GITHUB_ENV
            echo "TAG=dev" >> $GITHUB_ENV
            echo "PORT=3001" >> $GITHUB_ENV
            echo "DOMAIN=test.hatesglobal.com" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "ENV=production" >> $GITHUB_ENV
            echo "TAG=main" >> $GITHUB_ENV
            echo "PORT=3000" >> $GITHUB_ENV
            echo "DOMAIN=hatesglobal.com" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/sandbox" ]]; then
            echo "ENV=sandbox" >> $GITHUB_ENV
            echo "TAG=sandbox" >> $GITHUB_ENV
            echo "PORT=3002" >> $GITHUB_ENV
            echo "DOMAIN=sandbox.hatesglobal.com" >> $GITHUB_ENV
          else
            echo "Error: Unknown branch"
            exit 1
          fi
          # Use the exact tag from build job for deployment
          echo "IMAGE_NAME=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.tag }}" >> $GITHUB_ENV

      # SSH into server and deploy using Docker Compose
      - name: SSH and Deploy
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            echo "Deploying version ${{ env.IMAGE_NAME }} to ${{ env.ENV }} environment (${{ env.DOMAIN }})"

            # Prepare deployment directory
            mkdir -p ~/cicd-nextapp && cd ~/cicd-nextapp

            # Create Docker Compose file
            cat << 'EOF' > docker-compose.yml
            version: '3.8'
            services:
              app:
                image: ${IMAGE_NAME}
                ports:
                  - "${PORT}:3000"
                environment:
                  - NODE_ENV=${ENV}
                  - DOMAIN=${DOMAIN}
                restart: unless-stopped
                healthcheck:
                  test: curl --fail -s http://localhost:3000/ || exit 1
                  interval: 30s
                  timeout: 9s
                  retries: 5
                  start_period: 30s
            EOF

            # Create environment file
            cat << EOF > .env
            IMAGE_NAME=${{ env.IMAGE_NAME }}
            PORT=${{ env.PORT }}
            NODE_ENV=${{ env.ENV }}
            DOMAIN=${{ env.DOMAIN }}
            EOF

            # Stop existing containers and clean up
            sudo docker compose down || true
            sudo docker image prune -af

            # Start new deployment
            sudo docker compose --env-file .env up -d

            echo "Successfully deployed version ${{ env.IMAGE_NAME }} to ${{ env.DOMAIN }}"
